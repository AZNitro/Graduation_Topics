use serde::{Serialize, Deserialize};
use std::error::Error;
use std::collections::HashMap;
use std::fs::File;
use std::io::{Read, Write};
extern crate aes_soft as aes;
extern crate block_modes;
use block_modes::{BlockMode, Cbc};
use block_modes::block_padding::Pkcs7;
use cipher::{NewBlockCipher, BlockCipher, BlockEncrypt, BlockDecrypt};
use cipher::generic_array::GenericArray;
use aes::Aes128;



#[derive(Deserialize)]
struct AuthResponse {
    access_token: String,
}

#[derive(Deserialize)]
struct Artist {
    name: String,
}

#[derive(Deserialize)]
struct SearchResult {
    tracks: Tracks,
}

#[derive(Deserialize)]
struct Tracks{
    items: Vec<Track>,
}

#[derive(Deserialize)]
struct Track {
    name: String,
    artists: Vec<Artist>,
    external_urls: HashMap<String, String>,
}
#[derive(Serialize, Deserialize)]
struct Config {
    client_id: String,
    client_secret: String,
}
async fn read_config() -> std::result::Result<Config, Box<dyn std::error::Error>> {
    let mut file = File::open("config.json")?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;
    let config: Config = serde_json::from_str(&content)?;
    Ok(config)
}

#[tokio::main]
async fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
    let client = reqwest::Client::new();
    let access_token = get_access_token(&client).await?;


    println!("Enter song name or Spotify URL: ");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    let input = input.trim();
    if input.starts_with("http://") || input.starts_with("https://") || input.starts_with("/"){
        fn extract_track_id_from_url(url: &str) -> Option<&str> {
            url.rsplit('/').next()
        }
        
        async fn get_track_info(client: &reqwest::Client, track_id: &str, access_token: &str) -> std::result::Result<Track, Box<dyn std::error::Error>> {
            let url = format!("https://api.spotify.com/v1/tracks/{}", track_id); // ???閮剝????舐?脣????唾??靽⊥?舐??URL璅⊥??
            let response = client
                .get(&url)
                .header("Authorization", format!("Bearer {}", access_token))
                .send()
                .await
                .map_err(|e| -> Box<dyn std::error::Error> { From::from(e) })?;
        
            let body = response.text().await.map_err(|e| -> Box<dyn std::error::Error> { From::from(e) })?;
            let track: Track = serde_json::from_str(&body)?;
        
            Ok(track)
        }
        
        
        let track_id = "some_track_id";
        let track_info = get_track_info(&client, track_id, &access_token).await?;
        print_track_infos(vec![track_info]);
    } else {
        let track_infos = search_track(&client, input, &access_token).await?;
        print_track_infos(track_infos);
    }
    
    Ok(())
    }
fn print_track_infos(track_infos: Vec<Track>) {
    println!(" ");
    println!("------------------------");
    for track_info in track_infos {
        let artist_names: Vec<String> = track_info.artists.into_iter().map(|artist| artist.name).collect();
        println!("Track: {}", track_info.name);
        println!("Artists: {}", artist_names.join(", "));
        if let Some(spotify_url) = track_info.external_urls.get("spotify") {
            println!("Spotify URL: {}", spotify_url);
        }
        println!("------------------------");
    }
}
async fn search_track(client: &reqwest::Client, track_name: &str, access_token: &str) -> Result<Vec<Track>, Box<dyn Error>> {
    let search_url = format!("https://api.spotify.com/v1/search?q={}&type=track&limit=10", track_name);
    let response = client.get(&search_url)
        .header("Authorization", format!("Bearer {}", access_token))
        .send()
        .await?;

    let search_result: SearchResult = response.json().await?;
    let track_infos = search_result.tracks.items.into_iter().map(|track| {
        let artist_names: Vec<String> = track.artists.into_iter().map(|artist| artist.name).collect();
    let artists: Vec<Artist> = artist_names.into_iter().map(|name| Artist { name }).collect();
        Track{
            name: track.name,
            artists,
            external_urls: track.external_urls,
        }
    }).collect();
    Ok(track_infos)
}

// 加密並寫入配置
pub async fn write_encrypted_config(client_id: &str, client_secret: &str, key: &[u8; 16], iv: &[u8; 16]) -> Result<(), Box<dyn Error>> {
    let config = Config {
        client_id: base64::encode(&encrypt::<aes::Aes128>(client_id, key, iv)?),
        client_secret: base64::encode(&encrypt::<aes::Aes128>(client_secret, key, iv)?),
    };
    let config_str = serde_json::to_string(&config)?;
    let mut file = File::create("config.json")?;
    file.write_all(config_str.as_bytes())?;
    Ok(())
}
// 讀取並解密配置

pub async fn read_encrypted_config() -> Result<Config, Box<dyn std::error::Error>> {
    let key = b"0123456789012345"; // 16バイトのキーを設定する
    let iv = b"0123456789012345"; // 16バイトの初期化ベクトルを設定する

    let mut file = File::open("config.json")?;
    let mut config_str = String::new();
    file.read_to_string(&mut config_str)?;
    let mut config: Config = serde_json::from_str(&config_str)?;

    config.client_id = decrypt::<Aes128>(&config.client_id, key, iv)?;
    config.client_secret = decrypt::<Aes128>(&config.client_secret, key, iv)?;

    Ok(config)
}
type Aes128Cbc = Cbc<Aes128, Pkcs7>;

fn encrypt<C: NewBlockCipher + BlockEncrypt>(
    data: &str,
    key: &[u8],
    iv: &[u8; 16],
) -> Result<String, Box<dyn std::error::Error>> {
    let cipher = C::new_varkey(key).map_err(|_| "Invalid key length")?;
    let mut block_mode = Cbc::<C, Pkcs7>::new(cipher, GenericArray::from_slice(iv));
    let mut data_bytes = data.as_bytes().to_vec();
    block_mode.encrypt(&mut data_bytes);
    Ok(base64::encode(&data_bytes))
}

fn decrypt<C: NewBlockCipher + BlockDecrypt>(
    cipher_text: &str,
    key: &[u8],
    iv: &[u8; 16],
) -> Result<String, Box<dyn std::error::Error>> {
    let cipher = C::new_varkey(key).map_err(|_| "Invalid key length")?;
    let mut block_mode = Cbc::<C, Pkcs7>::new(cipher, GenericArray::from_slice(iv));
    let data_bytes = base64::decode(cipher_text)?;
    let mut decrypted_data = block_mode.decrypt_vec(&data_bytes)?;
    Ok(String::from_utf8(decrypted_data)?)
}

  
async fn get_access_token(client: &reqwest::Client) -> Result<String, Box<dyn Error>> {
    let config = read_config().await?;
    let client_id = config.client_id;
    let client_secret = config.client_secret;

    let auth_url = "https://accounts.spotify.com/api/token";
    let body = "grant_type=client_credentials";
    let auth_header = base64::encode(format!("{}:{}", client_id, client_secret));
    let request = client
        .post(auth_url)
        .header("Authorization", format!("Basic {}", auth_header))
        .header("Content-Type", "application/x-www-form-urlencoded")
        .body(body);

    let response = request.send().await?;
    let auth_response: AuthResponse = response.json().await?;

    Ok(auth_response.access_token)
}
